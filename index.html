<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
    <meta charset="UTF-8">

    <title>Propositions Classification</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <link rel="stylesheet" href="index.css">
</head>

<body>

    <main>
        <article>
            <div class="article-header">
                <div class="headline">
                    <p>Discrete Mathematics</p>
                    <h1>Classification of a Propositions</h1>
                    <div class="byline">by Aansh Sardana</div>
                </div>
                <div class="image"></div>
            </div>
            <div class="article-text">
                <h1 style="color: rgb(187, 110, 62); text-align: center">Program to Classify the proposition</h1>
                <h2>Properties of Propositions: <span class="nowrap">Tautologies, Contradictions, and
                        Contingencies</span></h2>

                <p>We&rsquo;ve seen how to use truth tables and the truth assignment test to determine whether an argument is valid or invalid. Those same tools also allow us to examine the logical properties of individual propositions and the logical relations
                    between propositions. Logical properties of propositions are considered below; some important logical relations will be introduced on the next page.</p>

                <p>Propositions can be classified into three categories: tautologies, contradictions, and contingencies. Whether a proposition is a tautology, contradiction, or contingency depends on its <a href="properties_of_arguments.html#form">form</a>&mdash;it&rsquo;s
                    logical structure.</p>

                <ul>
                    <li>
                        <p>A <dfn>tautology</dfn>, or <dfn>tautologous proposition</dfn>, has a logical form that cannot possibly be false (no matter what truth values are assigned to the sentence letters).</p>

                        <div class="examples">
                            The following propositions are tautologies:
                            <ul style="list-style-type:none; margin-bottom:0">
                                <li>(A &sup; A)
                                    <li>(A &or; ~A)
                                        <li>~(A &bull; ~A)
                                            <li>((A &bull; B) &sup; (A &or; B))
                                                <li>((A &or; B) &equiv; (B &or; A))
                            </ul>
                        </div>
                        </li>

                        <li>
                            <p>A <dfn>contradiction</dfn>, or <dfn>self-contradictory proposition</dfn>, has a logical form that cannot possibly be true (no matter what truth values are assigned to the sentence letters).
                            </p>

                            <div class="examples">
                                The following propositions are contradictions:
                                <ul style="list-style-type:none; margin-bottom:0">
                                    <li>(A &bull; ~A)
                                        <li>~(A &or; ~A)
                                            <li>~(A &sup; A)
                                                <li>((A &or; ~A) &sup; (B &bull; ~B))
                                                    <li>~((A &or; B) &equiv; (B &or; A))
                                </ul>
                            </div>
                            </li>

                            <li>
                                <p>A <dfn>contingency</dfn>, or <dfn>contingent proposition</dfn>, has a logical form that can be either true or false (depending on what truth values are assigned to the sentence letters).
                                </p>

                                <div class="examples">
                                    The following propositions are contingencies:
                                    <ul style="list-style-type:none; margin-bottom:0">
                                        <li>A
                                            <li>~A
                                                <li>(A &or; B)
                                                    <li>~(A &bull; B)
                                                        <li>(A &sup; B)
                                                            <li>((A &or; B) &sup; (C &bull; D))
                                                                <li>((A &bull; B) &equiv; (C &or; D))
                                    </ul>
                                </div>
                                </li>
                </ul>

                <hr>
                <hr>
                </br>
                <figure>
                    <figcaption>
                        <h1>C++ CODE --</h1>
                    </figcaption>
                    <pre style="padding: none;"><code contenteditable spellcheck="false" ><p id="p1">
        #include&lt;stdio.h&gt;
        #include&lt;string.h&gt;
        #include&lt;stdlib.h&gt; 
        #define MAX 130
        void push(int);
        char pop();
        void in2prefix();
         
        char stk[130],in[130],postfix[130];
        int top=-1;
        int lim,p=0,q=0,r;
        int n,bit,value;
        char arr[MAX],chars[MAX];
        int pos=0;
        #define small(j) ((j&lt;='z')&amp;&amp;(j&gt;='a'))
        void push(int sop)
        {
         
            if(top==130-1)
            {
                printf("stackfull!!!!");
            }
         
            else {
                top++;
                stk[top] = in[sop];
            }
        }
        char pop()
        {
            char ch;
         
            if(top &lt; 0)
            {
                printf("stackempty!!!!");
                exit(0);
            }
            else
            {
                ch=stk[top];
                stk[top]='\0';
                top--;
                return(ch);
            }
            return 0;
        }
        void in2prefix()
        {
            int i=0,j=0,k=0;
         
            i=0;
            j=strlen(in)-1;
            char temp;
        
            while(i&lt;j)
            {
                temp=in[i];
                in[i]=in[j];
                in[j]=temp;
                i++;
                j--;
            }
          i=0;
          j=0;
            while(in[i]!='\0')
            {
                if(in[i]&gt;='a' &amp;&amp; in[i]&lt;='z')        
                {
                    postfix[j]=in[i];
                    j++;
                    i++;
                }
                    else if(in[i]==')' || in[i]=='}'  || in[i]==']')      
                    {
                        push(i);
                        i++;
                    }
                else if(in[i]=='(' || in[i]=='{'  || in[i]=='[')       
                {
                    if(in[i]=='(')
                    {
                        while(stk[top]!=')')         
                        {
                            postfix[j]=pop();
                            j++;
                        }
                        pop();
                        i++;
                    }
         
                    else if(in[i]=='[')
                    {
                        while(stk[top]!=']')      
                        {
                            postfix[j]=pop();
                            j++;
                        }
                        pop();
                        i++;
                    }
         
                    else if(in[i]=='{')
                    {
                    while(stk[top]!='}')     
                        {
                            postfix[j]=pop();
                            j++;
                        }
                        pop();
                        i++;
                    }
                }
               else            
                {
                    if(top==-1)        
                    {
                        push(i);
                        i++;
                    }
                    else
                    {
                        push(i);
                        i++;
                    }
                }
            }
            while(top!=-1)
            {
                postfix[j]=pop();
                j++;
            }
            i=0;
            k=strlen(postfix)-1;
        
            while(i&lt;k)
            {
                temp=postfix[i];
                postfix[i]=postfix[k];
                postfix[k]=temp;
                i++;
                k--;
            }
          i=0;
            postfix[j]='\0';
        }
        int findliterals(const char *s,char *chars)
        {
           int cnt=0;
           int found[MAX]={};
           while(*s){
              if(small(*s))
                 if(!found[*s]){
                    chars[cnt++]=*s;
                    found[*s]=1;
                 }
              s++;
           }
           chars[cnt]='\0';
           return cnt;
        }
        void assignvaluestoliterals(int bit,int n,char *chars,char *arr)
        {
           int i;
           for(i=0;i&lt;n;i++)
              if(bit&amp;(1&lt;&lt;i))
                 {arr[chars[i]]=1;}
              else 
              {arr[chars[i]]=0;}
        }
        int compute(char ch, int old,int o)
        {
           switch(ch){
              case 'V': return old&amp;o;
                        break;
              case '^': return old|o;
                        break;
              case '-': 
                        if(old &amp;&amp;(!o)) return 0;
                        else return 1;
                        break;
              case '=': return 1^old^o;
                        break;
        
           };
           return 87243238;
        }
        
        int evaluate(char *postfix,char *arr)
        {
           int ans,a,b;
           char op;
           if(small(postfix[pos])){
              ans=arr[postfix[pos]];
              pos++;
              return ans;
           }
           else{
              if(postfix[pos]=='~'){
                 pos++;
                 ans= 1^evaluate(postfix,arr);
                 return ans;
              }
              else{
                 op=postfix[pos];
                 pos++;
                 a=evaluate(postfix,arr);
                 b=evaluate(postfix,arr);
                 ans=compute(op,a,b);
                 return ans;
              }
           }
        }
        int main()
        {
           int cont;
           printf("\n\nyour expression should follow these rules\n
           1)  Variables should be p and q only\n2)  Use V for AND\n
           3)  Use ^ for OR \n4)  Use - for if\n
           5)  Use = for if and only if\n
           6)  Use ~for nagation\n
           7)  Use simple brackets '()' for every expression\n") ;
            printf("\nEnter your expression\n");
              scanf("%s",in);
              in2prefix();
              
            
              n=findliterals(postfix,chars);
              lim=1&lt;&lt;n;
              for(bit=0;bit&lt;lim;bit++){
                 assignvaluestoliterals(bit,n,chars,arr);
                 pos=0;
                 value=evaluate(postfix,arr);
                 if(value==1) {p=1;}
                 if(value!=1){q=1;}
        
              }
              if(bit==lim&amp;&amp;q==0) 
                 {printf("THIS STATEMENT IS TAUTOLOGY\n");}
              else if(p==0)
              {
                  printf("THIS STATEMENT IS CONTRADICTION\n");
              }  
              else printf("THIS STATEMENT IS CONTINGENCY\n");
           
           return 0;
        }</p></code>    </pre>
                </figure>
                <h3>
                    <div> Try this code on <a href="https://www.codechef.com/ide?itm_medium=navmenu&itm_campaign=ide">codechef
                            practice</a></div>
                </h3>
                <h3>
                    <div> Source code on <a href="https://github.com/aansh-01/Proposition-Classification">codechef
                            practice</a></div>
                </h3>
                <h3>Screenshots-</h3>
                <h1 style="color: brown;"><dfn>Tautology - </dfn></h1>
                <img src="tautology.jpg" width="80%" height="30%" title="tautology" alt="tautology">
                <hr>
                <br>
                <br>
                <br>
                <h1 style="color: brown;"><dfn>Contradiction - </dfn></h1>
                <img src="contradiction.jpg" width="80%" height="30%" title="contradiction" alt="contradiction">
                <hr>
                <br>
                <br>
                <br>
                <h1 style="color: brown;"><dfn>Contingency - </dfn></h1>
                <img src="contingency.jpg" width="80%" height="30%" title="contingency" alt="contingency">
                <hr>
                <br>
                <br>
                <br>
        </article>
    </main>
    <footer>An exercise in <strong>CSS Grid</strong> (and drop caps)</footer>
</body>

</html>